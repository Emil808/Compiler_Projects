/**
 * <h1>Parser</h1>
 *
 * <p>A language-independent framework class.  This abstract parser class
 * will be implemented by language-specific subclasses.</p>
 *
 * <p>Copyright (c) 2017 by Ronald Mak</p>
 * <p>For instructional purposes only.  No warranties.</p>
 */
#ifndef WCI_FRONTEND_PARSER_H_
#define WCI_FRONTEND_PARSER_H_

#include "Scanner.h"
#include "../intermediate/SymTabStack.h"
#include "../intermediate/ICode.h"
#include "../message/Message.h"
#include "../message/MessageHandler.h"
#include "../message/MessageProducer.h"
#include "../message/MessageListener.h"

namespace wci { namespace frontend {

using namespace std;
using namespace wci::intermediate;
using namespace wci::message;

class Parser : MessageProducer
{
public:
    /**
     * Constructor.
     * @param scanner the scanner to be used with this parser.
     */
    Parser(Scanner *scanner) : scanner(scanner), icode(nullptr) {}

    /**
     * Destructor.
     */
    virtual ~Parser() {}

    /**
     * Getter.
     * @return the scanner used by this parser.
     */
    Scanner *get_scanner() const { return scanner; }

    /**
     * Getter.
     * @return the symbol table stack generated by this parser.
     */
    SymTabStack *get_symtab_stack() const { return symtab_stack; }

    /**
     * Getter.
     * @return the intermediate code generated by this parser.
     */
    ICode *get_icode() const { return icode; }

    /**
     * Getter.
     * @return the message handler.
     */
    MessageHandler& get_message_handler() const { return message_handler; }

    /**
     * Call the scanner's current_token() method.
     * @return the current token.
     */
    Token *current_token() { return scanner->current_token(); }

    /**
     * Call the scanner's next_token() method.
     * @param prev_token the previous token.
     * @return the next token.
     * @throw a string message if an error occurred.
     */
    Token *next_token(Token *prev_token) throw (string)
    {
        return scanner->next_token(prev_token);
    }

    /**
     * Parse a source program and generate the intermediate code and the
     * symbol table.  To be implemented by a language-specific parser
     * subclass.
     */
    virtual void parse() throw (string) = 0;

    /**
     * Return the number of syntax errors found by the parser.
     * To be implemented by a language-specific parser subclass.
     * @return the error count.
     */
    virtual int get_error_count() const = 0;

    /**
     * Add a message listener to the listener list.
     * Implementation of wci::message::MessageProducer.
     * @param listener the message listener to add.
     */
    void add_message_listener(MessageListener *listener)
    {
        message_handler.add_listener(listener);
    }

    /**
     * Send a message.
     * Implementation of wci::message::MessageProducer.
     * @param message the message to send.
     */
    void send_message(Message& message) const
    {
        message_handler.send_message(message);
    }

protected:
    static SymTabStack *symtab_stack;       // symbol table stack
    static MessageHandler message_handler;  // message handler delegate

    Scanner *scanner;  // scanner used with this parser
    ICode *icode;      // intermediate code generated by this parser
};

}} // namespace wci::frontend

#endif /* WCI_FRONTEND_PARSER_H_ */
